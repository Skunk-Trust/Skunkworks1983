#include "WPILib.h"
#include "math.h"

class SixWheelBot : public SimpleRobot
{
	RobotDrive myRobot; // robot drive system
	Joystick stickL; //Port 1
	Joystick stickR; //Port 2
	AxisCamera &camera;
	DigitalInput *left;			// digital inputs for line tracking sensors
	DigitalInput *middle;
	DigitalInput *right;

public:
	SixWheelBot(void):
		myRobot(1, 2, 3, 4),	// these must be initialized in the same order
		stickL(1), stickR(2),		// as they are declared above.
		AxisCamera.GetInstance()
	{
		myRobot.SetExpiration(0.1);
		left = new DigitalInput(1);
		middle = new DigitalInput(2);
		right = new DigitalInput(3);
	}

	/**
	 * Drive left & right motors for 2 seconds then stop
	 */
	void Autonomous() {
			myRobot.SetSafetyEnabled(false);
			double defaultSteeringGain = 0.65;	// default value for steering gain

			int binaryValue;
			int previousValue = 0;
			double steeringGain;

			// the power profiles for the straight and forked robot path. They are
			// different to let the robot drive more slowly as the robot approaches
			// the fork on the forked line case.
			double forkProfile[] = {0.70, 0.70, 0.55, 0.60, 0.60, 0.50, 0.40, 0.0};
			double straightProfile[] = {0.70, 0.70, 0.60, 0.60, 0.35, 0.35, 0.35, 0.0};

			double *powerProfile;  // the selected power profile
			
			// set the straight vs forked path variables as read from the DS digital
			// inputs or the I/O Setup panel on the driver station.
			//bool straightLine = ds->GetDigitalIn(1);
			bool straightLine = true; //BUGBUG change once BSD switch is added
			powerProfile = (straightLine) ? straightProfile : forkProfile;
			double stopTime = (straightLine) ? 2.0 : 4.0;
			//bool goLeft = !ds->GetDigitalIn(2) && !straightLine;
			bool goLeft = false; //BUGBUG change once BSD switch is added
			printf("StraightLine: %d\n", straightLine);
			printf("GoingLeft: %d\n", goLeft);

			bool atCross = false;	// true when robot has reached end

			// set up timer for 8 second max driving time and use the timer to
			// pick values from the power profile arrays
			Timer *timer = new Timer();
			timer->Start();
			timer->Reset();
			
			int oldTimeInSeconds = -1;
			double time;
			double speed, turn;

			// loop until either we hit the "T" at the end or 8 seconds has
			// elapsed. The time to the end should be less than 7 seconds
			// for either path.
			while ((time = timer->Get()) < 8.0 && !atCross) {
				int timeInSeconds = (int) time;
				int leftValue = left->Get() ? 1 : 0;	// read the line tracking sensors
				int middleValue = middle->Get() ? 1 : 0;
				int rightValue = right->Get() ? 1 : 0;

			    // compute the single value from the 3 sensors. Notice that the bits
			    // for the outside sensors are flipped depending on left or right
			    // fork. Also the sign of the steering direction is different for left/right.
				if (goLeft) {
					binaryValue = leftValue * 4 + middleValue * 2 + rightValue;
					steeringGain = -defaultSteeringGain;
				} else {
					binaryValue = rightValue * 4 + middleValue * 2 + leftValue;
					steeringGain = defaultSteeringGain;
				}

				speed = powerProfile[timeInSeconds];	// speed value for this time
				turn = 0;								// default to no turn

				switch (binaryValue) {
					case 1:					// just the outside sensor - drive straight
						turn = 0;
						break;
					case 7:					// all sensors - maybe at the "T"
					if (time> stopTime) {
						atCross = true;
						speed = 0;
					}
					break;
					case 0:					// no sensors - apply previous correction
					if (previousValue == 0 || previousValue == 1) {
						turn = steeringGain;
					}
					else {
						turn = -steeringGain;
					}
					break;
					default:				// anything else, steer back to the line
					turn = -steeringGain;
				}
				// useful debugging output for tuning your power profile and steering gain
				if(binaryValue != previousValue)
					printf("Time: %2.2f sensor: %d speed: %1.2f turn: %1.2f atCross: %d\n", time, binaryValue, speed, turn, atCross);
				// move the robot forward
				myRobot.ArcadeDrive(speed, turn);
				if (binaryValue != 0) previousValue = binaryValue;
				oldTimeInSeconds = timeInSeconds;
				Wait(0.01);
			}
			// stop driving when finished
			myRobot.ArcadeDrive(0.0, 0.0);
		}

	void OperatorControl(void)
	{
		myRobot.SetSafetyEnabled(false);
		//myRobot.SetInvertedMotor(kFrontLeftMotor, true);
		//	myRobot.SetInvertedMotor(3, true);
		float LeftY;
		float RightY;
		while (IsOperatorControl())
		{
			
			LeftY = stickL.GetY();
			RightY = stickR.GetY();
			LeftY = myRobot.Limit(LeftY);
			RightY = myRobot.Limit(RightY);
			if(fabs(LeftY) >= 0.05 && fabs(RightY) >= 0.05)
			{
				myRobot.TankDrive(LeftY, RightY);
			}
			else if(fabs(LeftY) >= 0.05 && !(fabs(RightY) >= 0.05))
			{
				myRobot.TankDrive(LeftY, 0.0);
			}
			else if(!(fabs(LeftY) >= 0.05) && fabs(RightY) >= 0.05)
			{
				myRobot.TankDrive(0.0, RightY);
			}
			else myRobot.TankDrive(0.0, 0.0);
//			myRobot.m_frontLeftMotor->Set(LeftY);
//			myRobot.m_frontRightMotor->Set(RightY);
//			myRobot.m_rearLeftMotor->Set(LeftY);
//			myRobot.m_rearRightMotor->Set(RightY);
			
			Wait(0.005);				// wait for a motor update time
		}
	}
};

START_ROBOT_CLASS(SixWheelBot);

